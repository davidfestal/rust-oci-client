/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * OCI Distribution client for interacting with OCI registries.
 * Provides pull, push, and manifest operations.
 */
export declare class OciClient {
  /** Create a new OCI client with default configuration. */
  constructor()
  /** Create a new OCI client with custom configuration. */
  static withConfig(config: ClientConfig): OciClient
  /**
   * Pull an image from the registry.
   *
   * Arguments match native: `pull(image: &Reference, auth: &RegistryAuth, accepted_media_types: Vec<&str>)`
   *
   * Returns ImageData containing layers (as Buffers), config, and manifest.
   */
  pull(image: string, auth: RegistryAuth, acceptedMediaTypes: Array<string>): Promise<ImageData>
  /**
   * Push an image to the registry.
   *
   * Arguments match native: `push(image_ref: &Reference, layers: &[ImageLayer], config: Config, auth: &RegistryAuth, manifest: Option<OciImageManifest>)`
   *
   * Returns PushResponse with config and manifest URLs.
   */
  push(imageRef: string, layers: Array<ImageLayer>, config: Config, auth: RegistryAuth, manifest?: ImageManifest | undefined | null): Promise<PushResponse>
  /**
   * Pull referrers for an artifact (OCI 1.1 Referrers API).
   *
   * Arguments match native: `pull_referrers(image: &Reference, artifact_type: Option<&str>)`
   *
   * Returns an ImageIndex containing the referrers.
   */
  pullReferrers(image: string, artifactType?: string | undefined | null): Promise<ImageIndex>
  /**
   * Push a manifest list (image index) to the registry.
   *
   * Arguments match native: `push_manifest_list(reference: &Reference, auth: &RegistryAuth, manifest: OciImageIndex)`
   *
   * Returns the manifest URL.
   */
  pushManifestList(reference: string, auth: RegistryAuth, manifest: ImageIndex): Promise<string>
  /**
   * Pull an image manifest from the registry.
   *
   * Arguments match native: `pull_image_manifest(image: &Reference, auth: &RegistryAuth)`
   *
   * If a multi-platform Image Index manifest is encountered, a platform-specific
   * Image manifest will be selected using the client's default platform resolution.
   *
   * Returns both the manifest and its digest.
   */
  pullImageManifest(image: string, auth: RegistryAuth): Promise<PullImageManifestResult>
  /**
   * Store authentication credentials for a registry.
   * This is useful for pre-authenticating before multiple operations.
   */
  storeAuth(registry: string, auth: RegistryAuth): Promise<void>
  /**
   * Pull a manifest (either image or index) from the registry.
   * Returns the manifest and its digest.
   */
  pullManifest(image: string, auth: RegistryAuth): Promise<PullManifestResult>
  /** Pull a manifest as raw bytes. */
  pullManifestRaw(image: string, auth: RegistryAuth, acceptedMediaTypes: Array<string>): Promise<Buffer>
  /**
   * Push a manifest to the registry.
   * Returns the manifest URL.
   */
  pushManifest(image: string, manifest: Manifest): Promise<string>
  /**
   * Push a blob to the registry.
   * Returns the blob digest.
   */
  pushBlob(image: string, data: Buffer, digest: string): Promise<string>
  /**
   * Pull a blob from the registry.
   * Returns the blob data.
   */
  pullBlob(image: string, digest: string): Promise<Buffer>
  /** Check if a blob exists in the registry. */
  blobExists(image: string, digest: string): Promise<boolean>
  /** Mount a blob from another repository. */
  mountBlob(target: string, source: string, digest: string): Promise<void>
  /** List tags for a repository. */
  listTags(image: string, auth: RegistryAuth, n?: number | undefined | null, last?: string | undefined | null): Promise<Array<string>>
  /** Fetch manifest digest without downloading the full manifest. */
  fetchManifestDigest(image: string, auth: RegistryAuth): Promise<string>
}

/** Create an anonymous authentication object. */
export declare function anonymousAuth(): RegistryAuth

/** Create a basic authentication object. */
export declare function basicAuth(username: string, password: string): RegistryAuth

/** Create a bearer token authentication object. */
export declare function bearerAuth(token: string): RegistryAuth

/**
 * A x509 certificate for TLS.
 * Mirrors the native Certificate struct.
 */
export interface Certificate {
  /** Which encoding is used by the certificate */
  encoding: CertificateEncoding
  /** Certificate data as bytes */
  data: Buffer
}

/**
 * Certificate encoding format.
 * Mirrors the native CertificateEncoding enum.
 */
export declare const enum CertificateEncoding {
  /** DER encoded certificate */
  Der = 'Der',
  /** PEM encoded certificate */
  Pem = 'Pem'
}

/**
 * Client configuration options.
 * Mirrors the native ClientConfig struct with all available options.
 */
export interface ClientConfig {
  /** Which protocol the client should use (default: Https) */
  protocol?: ClientProtocol
  /** List of registries to exclude from HTTPS (used with HttpsExcept protocol) */
  httpsExceptRegistries?: Array<string>
  /** Accept invalid certificates (default: false) */
  acceptInvalidCertificates?: boolean
  /** Use monolithic push for pushing blobs (default: false) */
  useMonolithicPush?: boolean
  /** Extra root certificates to trust (for self-signed certificates) */
  extraRootCertificates?: Array<Certificate>
  /** Maximum number of concurrent uploads during push (default: 16) */
  maxConcurrentUpload?: number
  /** Maximum number of concurrent downloads during pull (default: 16) */
  maxConcurrentDownload?: number
  /** Default token expiration in seconds (default: 60) */
  defaultTokenExpirationSecs?: number
  /** Read timeout in milliseconds */
  readTimeoutMs?: number
  /** Connect timeout in milliseconds */
  connectTimeoutMs?: number
  /** HTTPS proxy URL */
  httpsProxy?: string
  /** HTTP proxy URL */
  httpProxy?: string
  /** No proxy list (comma-separated) */
  noProxy?: string
}

/**
 * Protocol configuration for the client.
 * Mirrors the native ClientProtocol enum.
 */
export declare const enum ClientProtocol {
  /** Use HTTP (insecure) */
  Http = 'Http',
  /** Use HTTPS (secure, default) */
  Https = 'Https',
  /** Use HTTPS except for specified registries */
  HttpsExcept = 'HttpsExcept'
}

/**
 * Configuration object for an image.
 * Mirrors the native Config struct.
 */
export interface Config {
  /** The config data as raw bytes */
  data: Buffer
  /** The media type of this config */
  mediaType: string
  /** Optional annotations for this config */
  annotations?: Record<string, string>
}

/** OCI Descriptor - describes a content addressable resource. */
export interface Descriptor {
  /** The media type of the referenced content */
  mediaType: string
  /** The digest of the targeted content */
  digest: string
  /** The size in bytes of the targeted content */
  size: number
  /** Optional list of URLs from which this object may be downloaded */
  urls?: Array<string>
  /** Optional annotations for this descriptor */
  annotations?: Record<string, string>
}

/** The mediatype for an image config (manifest) */
export const IMAGE_CONFIG_MEDIA_TYPE: string

/** The mediatype that Docker uses for image configs */
export const IMAGE_DOCKER_CONFIG_MEDIA_TYPE: string

/** The mediatype that Docker uses for a layer that is gzipped */
export const IMAGE_DOCKER_LAYER_GZIP_MEDIA_TYPE: string

/** The mediatype that Docker uses for a layer that is tarred */
export const IMAGE_DOCKER_LAYER_TAR_MEDIA_TYPE: string

/** The mediatype for a layer that is gzipped */
export const IMAGE_LAYER_GZIP_MEDIA_TYPE: string

/** The mediatype for a layer */
export const IMAGE_LAYER_MEDIA_TYPE: string

/** The mediatype for a layer that is nondistributable and gzipped */
export const IMAGE_LAYER_NONDISTRIBUTABLE_GZIP_MEDIA_TYPE: string

/** The mediatype for a layer that is nondistributable */
export const IMAGE_LAYER_NONDISTRIBUTABLE_MEDIA_TYPE: string

/** The mediatype for a Docker v2 schema 2 manifest list */
export const IMAGE_MANIFEST_LIST_MEDIA_TYPE: string

/** The mediatype for a Docker v2 schema 2 manifest */
export const IMAGE_MANIFEST_MEDIA_TYPE: string

/**
 * Data returned from pulling an image.
 * Mirrors the native ImageData struct.
 */
export interface ImageData {
  /** The layers of the image */
  layers: Array<ImageLayer>
  /** The digest of the image (if available) */
  digest?: string
  /** The configuration object of the image */
  config: Config
  /** The manifest (if available) */
  manifest?: ImageManifest
}

/** OCI Image Index (manifest list). */
export interface ImageIndex {
  /** Schema version (always 2) */
  schemaVersion: number
  /** Media type of this manifest */
  mediaType?: string
  /** List of manifests for specific platforms */
  manifests: Array<ManifestEntry>
  /** Artifact type */
  artifactType?: string
  /** Annotations */
  annotations?: Record<string, string>
}

/**
 * An image layer with data and metadata.
 * Mirrors the native ImageLayer struct.
 */
export interface ImageLayer {
  /** The layer data as raw bytes */
  data: Buffer
  /** The media type of this layer */
  mediaType: string
  /** Optional annotations for this layer */
  annotations?: Record<string, string>
}

/** OCI Image Manifest. */
export interface ImageManifest {
  /** Schema version (always 2) */
  schemaVersion: number
  /** Media type of this manifest */
  mediaType?: string
  /** The image configuration descriptor */
  config: Descriptor
  /** The image layers */
  layers: Array<Descriptor>
  /** Subject descriptor (for referrers) */
  subject?: Descriptor
  /** Artifact type */
  artifactType?: string
  /** Annotations */
  annotations?: Record<string, string>
}

/**
 * OCI Manifest - can be either an Image manifest or an ImageIndex.
 * Check `manifest_type` to determine which field is populated.
 */
export interface Manifest {
  /** The type of manifest */
  manifestType: ManifestType
  /** The image manifest (populated when manifest_type is Image) */
  image?: ImageManifest
  /** The image index (populated when manifest_type is ImageIndex) */
  imageIndex?: ImageIndex
}

/** An entry in an image index manifest. */
export interface ManifestEntry {
  /** Media type of the manifest */
  mediaType: string
  /** Digest of the manifest */
  digest: string
  /** Size in bytes */
  size: number
  /** Platform specification */
  platform?: PlatformSpec
  /** Annotations */
  annotations?: Record<string, string>
}

/** Manifest type discriminator. */
export declare const enum ManifestType {
  /** An OCI image manifest */
  Image = 'Image',
  /** An OCI image index (manifest list) */
  ImageIndex = 'ImageIndex'
}

/** The mediatype for an OCI image index manifest */
export const OCI_IMAGE_INDEX_MEDIA_TYPE: string

/** The mediatype for an OCI image manifest */
export const OCI_IMAGE_MEDIA_TYPE: string

/** Contact details of the people or organization responsible for the image (freeform string) */
export const ORG_OPENCONTAINERS_IMAGE_AUTHORS: string

/** Digest of the image this image is based on (string) */
export const ORG_OPENCONTAINERS_IMAGE_BASE_DIGEST: string

/** Image reference of the image this image is based on (string) */
export const ORG_OPENCONTAINERS_IMAGE_BASE_NAME: string

/** Date and time on which the image was built (string, date-time as defined by RFC 3339) */
export const ORG_OPENCONTAINERS_IMAGE_CREATED: string

/** Human-readable description of the software packaged in the image (string) */
export const ORG_OPENCONTAINERS_IMAGE_DESCRIPTION: string

/** URL to get documentation on the image (string) */
export const ORG_OPENCONTAINERS_IMAGE_DOCUMENTATION: string

/** License(s) under which contained software is distributed as an SPDX License Expression */
export const ORG_OPENCONTAINERS_IMAGE_LICENSES: string

/** Name of the reference for a target (string) */
export const ORG_OPENCONTAINERS_IMAGE_REF_NAME: string

/** Source control revision identifier for the packaged software */
export const ORG_OPENCONTAINERS_IMAGE_REVISION: string

/** URL to get source code for building the image (string) */
export const ORG_OPENCONTAINERS_IMAGE_SOURCE: string

/** Human-readable title of the image (string) */
export const ORG_OPENCONTAINERS_IMAGE_TITLE: string

/** URL to find more information on the image (string) */
export const ORG_OPENCONTAINERS_IMAGE_URL: string

/** Name of the distributing entity, organization or individual */
export const ORG_OPENCONTAINERS_IMAGE_VENDOR: string

/** Version of the packaged software */
export const ORG_OPENCONTAINERS_IMAGE_VERSION: string

/** Platform specification for an image. */
export interface PlatformSpec {
  /** CPU architecture */
  architecture: string
  /** Operating system */
  os: string
  /** OS version */
  osVersion?: string
  /** OS features */
  osFeatures?: Array<string>
  /** CPU variant */
  variant?: string
  /** Additional features */
  features?: Array<string>
}

/** Result from pull_image_manifest containing both manifest and digest. */
export interface PullImageManifestResult {
  /** The pulled image manifest */
  manifest: ImageManifest
  /** The digest of the manifest */
  digest: string
}

/** Result from pull_manifest containing both manifest and digest. */
export interface PullManifestResult {
  /** The pulled manifest */
  manifest: Manifest
  /** The digest of the manifest */
  digest: string
}

/**
 * Response from pushing an image.
 * Mirrors the native PushResponse struct.
 */
export interface PushResponse {
  /** Pullable URL for the config */
  configUrl: string
  /** Pullable URL for the manifest */
  manifestUrl: string
}

/**
 * Registry authentication configuration.
 * Use `auth_type` to specify the authentication method.
 */
export interface RegistryAuth {
  /** The type of authentication to use */
  authType: RegistryAuthType
  /** Username for Basic auth (required when auth_type is Basic) */
  username?: string
  /** Password for Basic auth (required when auth_type is Basic) */
  password?: string
  /** Token for Bearer auth (required when auth_type is Bearer) */
  token?: string
}

/**
 * Authentication method for registry access.
 * Mirrors the native RegistryAuth enum exactly.
 */
export declare const enum RegistryAuthType {
  /** Access the registry anonymously */
  Anonymous = 'Anonymous',
  /** Access the registry using HTTP Basic authentication */
  Basic = 'Basic',
  /** Access the registry using Bearer token authentication */
  Bearer = 'Bearer'
}

/** The mediatype for a WASM image config */
export const WASM_CONFIG_MEDIA_TYPE: string

/** The mediatype for WASM layers */
export const WASM_LAYER_MEDIA_TYPE: string
